name: Release

on:
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: write
  packages: write
  id-token: write         # for keyless cosign + attestations
  attestations: write

env:
  IMAGE_NAME: ghcr.io/${{ github.repository }}

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # GHCR requires lowercase image names
      - name: Compute IMAGE_NAME (lowercase)
        run: echo "IMAGE_NAME=ghcr.io/${GITHUB_REPOSITORY,,}" >> "$GITHUB_ENV"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install release tooling
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Generate OpenAPI schema
        run: |
          mkdir -p dist
          scripts/generate_openapi.py --output dist/openapi.json

      - name: Build debug bundle
        run: |
          scripts/build_dist_tarball.sh

      - name: Extract version from tag
        id: version
        run: echo "version=${GITHUB_REF_NAME}" >> "$GITHUB_OUTPUT"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=tag
            type=raw,value=latest

      # Single build & push (multi-arch) with provenance + SBOM emitted as attestations
      - name: Build and push image
        id: push
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          provenance: mode=max      # generates SLSA provenance attestation
          sbom: true                # generates SBOM attestation
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # Publish provenance attestation via GitHub to OCI (ties it to the pushed digest)
      - name: Attest build provenance (GitHub -> OCI)
        uses: actions/attest-build-provenance@v3
        with:
          subject-name: ${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

      - name: Capture digest
        run: |
          echo "IMAGE_DIGEST=${{ steps.push.outputs.digest }}" >> "$GITHUB_ENV"
          echo "${{ steps.push.outputs.digest }}" > dist/image-digest.txt
          echo "Captured digest: ${{ steps.push.outputs.digest }}"

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      # Optional but recommended: sign the image manifest (keyless)
      - name: Sign image with Cosign
        run: |
          cosign sign --yes "${IMAGE_NAME}@${IMAGE_DIGEST}"

      # Verify the provenance attestation produced above (gate on repo identity)
      - name: Verify SLSA provenance attestation
        run: |
          cosign verify-attestation \
            --type slsaprovenance \
            --certificate-oidc-issuer https://token.actions.githubusercontent.com \
            --certificate-identity-regexp "^https://github.com/${{ github.repository }}(/.|@).*" \
            "${IMAGE_NAME}@${IMAGE_DIGEST}" \
            | jq . > /dev/null

      - name: Inspect OCI referrers (debug)
        run: |
          set -euo pipefail
          ref="${IMAGE_NAME}@${IMAGE_DIGEST}"
          echo "=== cosign tree (index) ==="
          cosign tree "${ref}" || true

      # Download provenance (.intoto.jsonl) and SBOM (SPDX) from the registry to ship with the release
      - name: Download provenance & SBOM
        run: |
          set -euo pipefail
          mkdir -p dist
          ref="${IMAGE_NAME}@${IMAGE_DIGEST}"

          # Retry a few times for eventual consistency on GHCR referrers
          tries=8
          delay=5
          got_index_attest=0
          for i in $(seq 1 ${tries}); do
            if cosign download attestation --predicate-type slsaprovenance "${ref}" > dist/provenance.intoto.jsonl 2>/dev/null; then
              echo "Fetched index-level provenance attestation."
              got_index_attest=1
              break
            fi
            echo "No index-level provenance yet (try ${i}/${tries}); sleeping ${delay}s..."
            sleep "${delay}"
          done

          # If index-level provenance not found, fall back to per-platform manifests
          if [ "${got_index_attest}" -eq 0 ]; then
            echo "Falling back to per-platform manifests…"
            docker buildx imagetools inspect --raw "${ref}" | jq -r '.manifests[].digest' > dist/_platform_digests.txt

            while read -r pd; do
              [ -n "$pd" ] || continue
              echo "Trying ${IMAGE_NAME}@${pd} for provenance…"
              if cosign download attestation --predicate-type slsaprovenance "${IMAGE_NAME}@${pd}" > "dist/provenance.${pd#sha256:}.intoto.jsonl" 2>/dev/null; then
                cp "dist/provenance.${pd#sha256:}.intoto.jsonl" dist/provenance.intoto.jsonl
                got_index_attest=1
                break
              fi
            done < dist/_platform_digests.txt
          fi

          if [ "${got_index_attest}" -eq 0 ] || [ ! -s dist/provenance.intoto.jsonl ]; then
            echo "ERROR: No provenance attestation found at index or platform manifests."
            echo "Tip: ensure 'actions/attest-build-provenance@v3' ran with 'push-to-registry: true' and the same subject digest."
            exit 1
          fi

          # SBOM: try index-level first, then per-platform
          if ! cosign download sbom "${ref}" > dist/sbom.spdx.json 2>/dev/null; then
            echo "No index-level SBOM found; trying per-platform manifests…"
            # If platform list not already generated, generate it
            if [ ! -f dist/_platform_digests.txt ]; then
              docker buildx imagetools inspect --raw "${ref}" | jq -r '.manifests[].digest' > dist/_platform_digests.txt
            fi
            while read -r pd; do
              [ -n "$pd" ] || continue
              echo "Trying ${IMAGE_NAME}@${pd} for SBOM…"
              if cosign download sbom "${IMAGE_NAME}@${pd}" > "dist/sbom.${pd#sha256:}.spdx.json" 2>/dev/null; then
                cp "dist/sbom.${pd#sha256:}.spdx.json" dist/sbom.spdx.json
                break
              fi
            done < dist/_platform_digests.txt
          fi

          # Deterministic, digest-suffixed copies for traceability
          cp dist/provenance.intoto.jsonl "dist/provenance.${IMAGE_DIGEST#sha256:}.intoto.jsonl"
          [ -f dist/sbom.spdx.json ] && cp dist/sbom.spdx.json "dist/sbom.${IMAGE_DIGEST#sha256:}.spdx.json" || true

      - name: Render release notes
        run: |
          python scripts/render_release_notes.py \
            --version "${{ steps.version.outputs.version }}" \
            --image-digest "${IMAGE_DIGEST}" \
            --owner "${{ github.repository_owner }}" \
            --output dist/release-notes.md

      - name: Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          body_path: dist/release-notes.md
          files: |
            dist/openapi.json
            dist/sbom.spdx.json
            dist/provenance.intoto.jsonl
            dist/dist.tar.gz
            example.env
            compose.service.yaml
            dist/image-digest.txt